import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { v4 as uuidv4 } from 'uuid';

export interface Clan {
  id: string;
  name: string;
  tag: string;
  description: string;
  ownerId: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface ClanMember {
  clanId: string;
  userId: string;
  role: 'owner' | 'admin' | 'member';
  joinedAt: Date;
}

export interface ClanMessage {
  id: string;
  clanId: string;
  userId: string;
  content: string;
  createdAt: Date;
}

export class ClanManager {
  private supabase: SupabaseClient;

  constructor(supabaseUrl: string, supabaseKey: string) {
    this.supabase = createClient(supabaseUrl, supabaseKey);
  }

  /**
   * Create a new clan
   */
  async createClan(name: string, tag: string, ownerId: string, description?: string): Promise<Clan> {
    try {
      // Validate tag format (uppercase alphanumeric, max 6 chars)
      if (!/^[A-Z0-9]{1,6}$/.test(tag)) {
        throw new Error('Tag must be 1-6 uppercase letters/numbers');
      }

      const clanId = uuidv4();

      // Create clan
      const { data: clanData, error: clanError } = await this.supabase
        .from('clans')
        .insert({
          id: clanId,
          name,
          tag,
          description: description || '',
          owner_id: ownerId
        })
        .select()
        .single();

      if (clanError) {
        if (clanError.code === '23505') { // Unique violation
          throw new Error('Clan name or tag already exists');
        }
        throw clanError;
      }

      // Add owner as member
      await this.supabase
        .from('clan_members')
        .insert({
          clan_id: clanId,
          user_id: ownerId,
          role: 'owner'
        });

      const clan: Clan = {
        id: clanData.id,
        name: clanData.name,
        tag: clanData.tag,
        description: clanData.description,
        ownerId: clanData.owner_id,
        createdAt: new Date(clanData.created_at),
        updatedAt: new Date(clanData.updated_at)
      };

      console.log(`Clan created: ${name} [${tag}]`);
      return clan;
    } catch (error) {
      console.error('Failed to create clan:', error);
      throw error;
    }
  }

  /**
   * Join a clan
   */
  async joinClan(clanId: string, userId: string): Promise<void> {
    try {
      const { error } = await this.supabase
        .from('clan_members')
        .insert({
          clan_id: clanId,
          user_id: userId,
          role: 'member'
        });

      if (error) {
        if (error.code === '23505') { // Already a member
          throw new Error('User is already a member of this clan');
        }
        throw error;
      }

      console.log(`User ${userId} joined clan ${clanId}`);
    } catch (error) {
      console.error('Failed to join clan:', error);
      throw error;
    }
  }

  /**
   * Leave a clan
   */
  async leaveClan(clanId: string, userId: string): Promise<void> {
    try {
      // Check if user is owner
      const { data: clanData } = await this.supabase
        .from('clans')
        .select('owner_id')
        .eq('id', clanId)
        .single();

      if (clanData && clanData.owner_id === userId) {
        throw new Error('Clan owner cannot leave. Transfer ownership or delete clan first.');
      }

      const { error } = await this.supabase
        .from('clan_members')
        .delete()
        .eq('clan_id', clanId)
        .eq('user_id', userId);

      if (error) {
        throw error;
      }

      console.log(`User ${userId} left clan ${clanId}`);
    } catch (error) {
      console.error('Failed to leave clan:', error);
      throw error;
    }
  }

  /**
   * Get clan members
   */
  async getClanMembers(clanId: string): Promise<ClanMember[]> {
    try {
      const { data, error } = await this.supabase
        .from('clan_members')
        .select('*')
        .eq('clan_id', clanId)
        .order('joined_at', { ascending: true });

      if (error) {
        throw error;
      }

      return (data || []).map(member => ({
        clanId: member.clan_id,
        userId: member.user_id,
        role: member.role,
        joinedAt: new Date(member.joined_at)
      }));
    } catch (error) {
      console.error('Failed to get clan members:', error);
      throw error;
    }
  }

  /**
   * Get user's clan
   */
  async getUserClan(userId: string): Promise<Clan | null> {
    try {
      const { data, error } = await this.supabase
        .rpc('get_user_clan', { p_user_id: userId })
        .single();

      if (error || !data) {
        return null;
      }

      return {
        id: data.clan_id,
        name: data.clan_name,
        tag: data.clan_tag,
        description: data.clan_description,
        ownerId: '', // Not returned by function
        createdAt: new Date(data.joined_at),
        updatedAt: new Date()
      };
    } catch (error) {
      console.error('Failed to get user clan:', error);
      return null;
    }
  }

  /**
   * Search clans
   */
  async searchClans(query: string): Promise<Clan[]> {
    try {
      const { data, error } = await this.supabase
        .rpc('search_clans', { p_query: query });

      if (error) {
        throw error;
      }

      return (data || []).map((clan: any) => ({
        id: clan.id,
        name: clan.name,
        tag: clan.tag,
        description: clan.description,
        ownerId: '',
        createdAt: new Date(clan.created_at),
        updatedAt: new Date()
      }));
    } catch (error) {
      console.error('Failed to search clans:', error);
      throw error;
    }
  }

  /**
   * Send clan message
   */
  async sendClanMessage(clanId: string, userId: string, content: string): Promise<ClanMessage> {
    try {
      // Verify user is a member
      const { data: memberData } = await this.supabase
        .from('clan_members')
        .select('user_id')
        .eq('clan_id', clanId)
        .eq('user_id', userId)
        .single();

      if (!memberData) {
        throw new Error('User is not a member of this clan');
      }

      const messageId = uuidv4();

      const { data, error } = await this.supabase
        .from('clan_messages')
        .insert({
          id: messageId,
          clan_id: clanId,
          user_id: userId,
          content
        })
        .select()
        .single();

      if (error) {
        throw error;
      }

      return {
        id: data.id,
        clanId: data.clan_id,
        userId: data.user_id,
        content: data.content,
        createdAt: new Date(data.created_at)
      };
    } catch (error) {
      console.error('Failed to send clan message:', error);
      throw error;
    }
  }

  /**
   * Get clan messages
   */
  async getClanMessages(clanId: string, limit: number = 50): Promise<ClanMessage[]> {
    try {
      const { data, error } = await this.supabase
        .from('clan_messages')
        .select('*')
        .eq('clan_id', clanId)
        .order('created_at', { ascending: false })
        .limit(limit);

      if (error) {
        throw error;
      }

      return (data || []).map(msg => ({
        id: msg.id,
        clanId: msg.clan_id,
        userId: msg.user_id,
        content: msg.content,
        createdAt: new Date(msg.created_at)
      })).reverse();
    } catch (error) {
      console.error('Failed to get clan messages:', error);
      throw error;
    }
  }

  /**
   * Update clan member role
   */
  async updateMemberRole(clanId: string, userId: string, newRole: 'admin' | 'member'): Promise<void> {
    try {
      const { error } = await this.supabase
        .from('clan_members')
        .update({ role: newRole })
        .eq('clan_id', clanId)
        .eq('user_id', userId);

      if (error) {
        throw error;
      }

      console.log(`Updated role for user ${userId} in clan ${clanId} to ${newRole}`);
    } catch (error) {
      console.error('Failed to update member role:', error);
      throw error;
    }
  }

  /**
   * Delete clan (owner only)
   */
  async deleteClan(clanId: string, ownerId: string): Promise<void> {
    try {
      // Verify ownership
      const { data: clanData } = await this.supabase
        .from('clans')
        .select('owner_id')
        .eq('id', clanId)
        .single();

      if (!clanData || clanData.owner_id !== ownerId) {
        throw new Error('Only clan owner can delete the clan');
      }

      const { error } = await this.supabase
        .from('clans')
        .delete()
        .eq('id', clanId);

      if (error) {
        throw error;
      }

      console.log(`Clan ${clanId} deleted by owner ${ownerId}`);
    } catch (error) {
      console.error('Failed to delete clan:', error);
      throw error;
    }
  }

  /**
   * Get clan by ID
   */
  async getClanById(clanId: string): Promise<Clan | null> {
    try {
      const { data, error } = await this.supabase
        .from('clans')
        .select('*')
        .eq('id', clanId)
        .single();

      if (error || !data) {
        return null;
      }

      return {
        id: data.id,
        name: data.name,
        tag: data.tag,
        description: data.description,
        ownerId: data.owner_id,
        createdAt: new Date(data.created_at),
        updatedAt: new Date(data.updated_at)
      };
    } catch (error) {
      console.error('Failed to get clan:', error);
      return null;
    }
  }
}

// Export singleton instance
let clanManagerInstance: ClanManager | null = null;

export function initializeClanManager(
  supabaseUrl: string,
  supabaseKey: string
): ClanManager {
  if (!clanManagerInstance) {
    clanManagerInstance = new ClanManager(supabaseUrl, supabaseKey);
  }
  return clanManagerInstance;
}

export function getClanManager(): ClanManager {
  if (!clanManagerInstance) {
    throw new Error('ClanManager not initialized. Call initializeClanManager first.');
  }
  return clanManagerInstance;
}
